/*
 *  theory.cpp
 *  Assignment 4 theory questions and answers
 *
 *  
 *   
 */

#include "utility.cpp"
#include <iostream>
#include <vector>
using namespace std;

/*
 7.38
 Suppose arrays A and B are both sorted and both contain N elements.
 Give an O(log N) algorithm to find the median of A U B.
 
 0. For two pre-sorted sets of length n
 1. Get median of both sets
 2. If medians are same, either one is the answer
 3. Else If aM > bM, 
	discard elements in a less than aM
	discards elements in b greater than bM
 4. Else if bM > aM
	discard elements in b less than bM
	discard elements in a greater than aM
 5. Recurse with the new size sets until we minimal size sets
 6. Calculate average of 
	add max of first elems of each set to the min of second elems of each set
	divide by 2 for average (mean)
 
 */


/*
 7.41
 a. Prove that any comparison-based algorithm to sort 4 elements requires 5 comparisons
 b. Give an algorithm to sort 4 elements in 5 comparisons

 a) log 4! is 24. 32 is next highest 2 exp. log 32 is 5, so 5 comparisons.
 
 b) pseudocode below. compare/swap 1-2, 3-4, 1-3, 2-4, and 2-3
 
	sort_increasing ( array a )
	{
		if (a1 > a2)
			swap(a1, a2)	// comparison 1
		if (a3 > a4)
			swap (a3, a4)	// comparison 2
		if (a1 > a3)
			swap (a1, a3)	// comparison 3
		if (a2 > a4)	
			swap (a2, a4)	// comparison 4
		if (a2 > a3)
			swap (a2, a3)	// comparison 5, done sorting
	}
 */


/*
 7.48
 We are given an array that contains N numbers. We want to determine if there eare
 two numbers whose sum equals a given number K. For instance, if the input is 8, 4, 1, 6,
 and K is 10, then the answer is yes (4 and 6). A number may be used twice. Do the following:

 b. Give an O(N log N) algorithm to solve this problem. (Hint: Sort the items first.
    After that is done, you can solve the problem in linear time.)

	psedocode below:
 
	bool find_sum ( array a, sum )
	{
		quicksort(a)					// O(N log N)
		start = 0, end = a.size - 1
		for each elem in a less than K	// O(N)
		{
			if (a[start] + a[end] > sum) 
				decrement end
			else if (a[start] + a[end] < sum) 
				incrememnt start
			else
				return true
		}
		return false
	}
*/


/*
 8.7
 Design an algorithm that generates a maze that contains no path from start to finish,
 but has the property that the removal of a prespecified wall creates a unique path.

 choose 2 random adjacent elements
 if start is in set for elem A and end is in set for elem B, re-choose
 join the 2 elements into the same set
 if the wall is vertical, knock down the vertical wall 
 if the wall is horizontal, knock down the horizontal and veritcal wall
 
 This creates a very small path, but it is unique for any given inner wall. 
 
 */
